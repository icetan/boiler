// Generated by CoffeeScript 1.3.3
(function() {
  var Boiler, hasProp, path_, relativeModule, toDict,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path_ = require('path');

  relativeModule = function(from, to) {
    return './' + path_.relative(path_.dirname(from), to).replace(/\\/g, '/');
  };

  toDict = function(kvps) {
    var dict, kvp, _i, _len;
    dict = {};
    for (_i = 0, _len = kvps.length; _i < _len; _i++) {
      kvp = kvps[_i];
      dict[kvp[0]] = kvp[1];
    }
    return dict;
  };

  hasProp = function(dict, props) {
    var prop, _i, _len;
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      if (prop in dict) {
        return true;
      }
    }
    return false;
  };

  Boiler = (function() {

    function Boiler() {
      this.debugging = false;
      this.filenameIdMap = {};
      this.id = 0;
      this.everything = '';
    }

    Boiler.prototype.require = function(file) {
      this.config = {
        exclude: [],
        path: ''
      };
      this.hookExtensions();
      require(path_.resolve(file));
      return this.unhookExtensions();
    };

    Boiler.prototype.filenameToId = function(filename) {
      if (!(filename in this.filenameIdMap)) {
        this.filenameIdMap[filename] = this.id += 1;
      }
      return this.filenameIdMap[filename];
    };

    Boiler.prototype.isExcluded = function(path, config) {
      if (config.excluded || __indexOf.call(config.exclude, path) >= 0) {
        return true;
      } else if (config.parent) {
        return this.isExcluded(path, config.parent);
      } else {
        return false;
      }
    };

    Boiler.injectScript = function(injects) {
      var alias, arg, args, scripts, strArgs;
      if (injects == null) {
        injects = {};
      }
      scripts = (function() {
        var _results;
        _results = [];
        for (alias in injects) {
          args = injects[alias];
          strArgs = ((function() {
            var _i, _len, _results1;
            _results1 = [];
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              arg = args[_i];
              _results1.push(JSON.stringify(arg));
            }
            return _results1;
          })()).join(',');
          _results.push("var " + alias + "=require(" + strArgs + ");\n");
        }
        return _results;
      })();
      if (scripts.length > 0) {
        return "// Boiler injects\n" + (scripts.join(''));
      } else {
        return '';
      }
    };

    Boiler.exportScript = function(exp) {
      if (exp) {
        return "\n;\n// Boiler exports\nmodule.exports=" + exp + ";";
      } else {
        return '';
      }
    };

    Boiler.requireWrap = function(content) {
      return "require = function(req) {\n  var require = function(path, opt) {\n    var res;\n    module.__boiler_hook_in(req.resolve, path, opt);\n    try {\n      res = req.call(this, path);\n    } catch (err) {\n      module.__boiler_hook_error(err);\n    } finally {\n      module.__boiler_hook_out();\n    }\n    return res;\n  };\n  for (var i in req) {\n    require[i] = req[i];\n  }\n  return require;\n}(require);\n" + content;
    };

    Boiler.boil = function(id, pathIdMap, code, filename) {
      return "register.call(this," + id + "," + (JSON.stringify(pathIdMap)) + ",\nfunction(require,exports,module){\n// Boiler file: " + (path_.relative(__dirname, filename)) + "\n" + code + "\n});";
    };

    Boiler.prototype.serve = function() {
      return "(function(everything){\n  window.boiler={main:{}};\n  var idModuleMap={};\n  function emulateRequire(pathIdMap){\n    function require(path, opt){\n      return idModuleMap[pathIdMap[path]];\n    }\n    return require;\n  }\n  function register(id,pathIdMap,factory){\n    var module={exports:{}};\n    factory.call(this,emulateRequire(pathIdMap),module.exports,module);\n    window.boiler.main=idModuleMap[id]=module.exports;\n  }\n  everything.call(this,register);\n}).call(this,function(register){\n" + this.everything + "\n});";
    };

    Boiler.prototype.getHook = function(ext, func) {
      var hook,
        _this = this;
      hook = function(module, filename) {
        var cmp, codeBrowser, deps, fn, path, pathIdMap, that;
        that = _this;
        codeBrowser = '';
        deps = {};
        cmp = module._compile;
        module.__boiler_hook_in = function(resolve, path, opt) {
          var alias, args, exclude, injects, p, reqOpt;
          if (opt == null) {
            opt = {};
          }
          _this.debug("hook into " + path + ":" + filename);
          if (typeof opt === 'string') {
            opt = {
              exports: opt
            };
          } else if (opt === true || opt instanceof Array) {
            opt = {
              exclude: opt
            };
          } else if (opt instanceof Object && !hasProp(opt, ['exclude', 'exports', 'injects'])) {
            opt = {
              injects: opt
            };
          }
          exclude = (function() {
            var _i, _len, _ref, _results;
            _ref = (opt.exclude instanceof Array ? opt.exclude : []);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              p = _ref[_i];
              _results.push(resolve(p));
            }
            return _results;
          })();
          injects = toDict((function() {
            var _ref, _ref1, _results;
            _ref = opt.injects || {};
            _results = [];
            for (alias in _ref) {
              p = _ref[alias];
              if (p instanceof Array) {
                _ref1 = p, p = _ref1[0], reqOpt = _ref1[1];
              }
              args = [relativeModule(resolve(path), resolve(p))];
              if (reqOpt != null) {
                args.push(reqOpt);
              }
              _results.push([alias, args]);
            }
            return _results;
          })());
          _this.config = {
            path: resolve(path),
            exclude: exclude,
            injects: injects,
            exports: opt.exports,
            excluded: opt.exclude === true || _this.isExcluded(resolve(path), _this.config),
            parent: _this.config
          };
          deps[path] = resolve(path);
          return _this.debug(_this.config);
        };
        module.__boiler_hook_error = function(err) {
          return _this.debug("hook error " + _this.config.path + ":" + filename + ": " + err);
        };
        module.__boiler_hook_out = function() {
          _this.debug("hook outof " + _this.config.path + ":" + filename);
          if (_this.config.parent) {
            return _this.config = _this.config.parent;
          }
        };
        module._compile = function(content, filename) {
          var code, codeNode;
          code = Boiler.injectScript(that.config.injects);
          code += content;
          code += Boiler.exportScript(that.config.exports);
          codeBrowser = code;
          codeNode = Boiler.requireWrap(code);
          return cmp.call(this, codeNode, filename);
        };
        try {
          func(module, filename);
        } catch (err) {
          _this.debug("error: " + err);
        }
        if (!_this.config.excluded) {
          _this.debug("boiling " + _this.config.path + ":" + filename);
          pathIdMap = toDict((function() {
            var _results;
            _results = [];
            for (path in deps) {
              fn = deps[path];
              _results.push([path, this.filenameToId(fn)]);
            }
            return _results;
          }).call(_this));
          _this.everything += Boiler.boil(_this.filenameToId(filename), pathIdMap, codeBrowser, filename);
        } else {
          _this.debug('excluded ' + filename);
        }
        return _this.hookExtensions();
      };
      hook.__boiler_hook_orig = func;
      return hook;
    };

    Boiler.prototype.unhookExtensions = function() {
      var ext, func, _ref, _results;
      _ref = require.extensions;
      _results = [];
      for (ext in _ref) {
        func = _ref[ext];
        if (func.__boiler_hook_orig != null) {
          _results.push(require.extensions[ext] = func.__boiler_hook_orig);
        }
      }
      return _results;
    };

    Boiler.prototype.hookExtensions = function() {
      var ext, func, _ref, _results;
      _ref = require.extensions;
      _results = [];
      for (ext in _ref) {
        func = _ref[ext];
        if (!(func.__boiler_hook_orig != null)) {
          _results.push(require.extensions[ext] = this.getHook(ext, func));
        }
      }
      return _results;
    };

    Boiler.prototype.debug = function() {
      if (this.debugging) {
        return console.log.apply(this, arguments);
      }
    };

    return Boiler;

  })();

  module.exports = function(file, debug) {
    var boiler;
    if (debug == null) {
      debug = false;
    }
    boiler = new Boiler;
    boiler.debugging = debug;
    boiler.require(file);
    if (debug) {
      return '';
    } else {
      return boiler.serve();
    }
  };

  module.exports.Boiler = Boiler;

}).call(this);
