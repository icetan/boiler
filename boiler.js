// Generated by CoffeeScript 1.3.3
(function() {
  var Boiler, Pot, debug, hasProp, path_, relativeModule, toDict,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  debug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (module.exports.debug) {
      return console.log.apply(console, args);
    }
  };

  path_ = require('path');

  relativeModule = function(from, to) {
    return './' + path_.relative(path_.dirname(from), to).replace(/\\/g, '/');
  };

  toDict = function(kvps) {
    var dict, kvp, _i, _len;
    dict = {};
    for (_i = 0, _len = kvps.length; _i < _len; _i++) {
      kvp = kvps[_i];
      dict[kvp[0]] = kvp[1];
    }
    return dict;
  };

  hasProp = function(dict, props) {
    var prop, _i, _len;
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      if (prop in dict) {
        return true;
      }
    }
    return false;
  };

  Pot = (function() {

    function Pot(filename, recursive) {
      this.recursive = recursive != null ? recursive : true;
      this.config = {
        filename: filename,
        deps: {},
        exclude: []
      };
    }

    Pot.prototype.require = function() {
      var mod;
      Boiler.hookExtensions(this);
      mod = require(this.config.filename);
      Boiler.unhookExtensions();
      return mod;
    };

    Pot.prototype.boil = function() {
      this.require();
      return this.config;
    };

    return Pot;

  })();

  Boiler = (function() {

    function Boiler() {
      this.pots = {};
      this.filenameIdMap = {};
      this.id = 0;
      this.hooked = false;
    }

    Boiler.prototype.add = function(filename) {
      filename = path_.resolve(filename);
      if (!(filename in this.pots)) {
        return this.pots[filename] = new Pot(filename);
      }
    };

    Boiler.prototype.boil = function(config) {
      var cfg, codes, path, pathIdMap;
      if ((config.code != null) && !config.excluded) {
        codes = ((function() {
          var _ref, _results;
          _ref = config.deps;
          _results = [];
          for (path in _ref) {
            cfg = _ref[path];
            _results.push(this.boil(cfg));
          }
          return _results;
        }).call(this)).join('\n');
        debug("boiling " + config.filename);
        pathIdMap = toDict((function() {
          var _ref, _results;
          _ref = config.deps;
          _results = [];
          for (path in _ref) {
            cfg = _ref[path];
            _results.push([path, this.filenameToId(cfg.filename)]);
          }
          return _results;
        }).call(this));
        return codes += Boiler.registerWrap(this.filenameToId(config.filename), pathIdMap, config.code, config.filename);
      } else {
        debug('excluded ' + config.filename);
        return '';
      }
    };

    Boiler.prototype.serve = function() {
      var fn, pot;
      return Boiler.browserWrap(((function() {
        var _ref, _results;
        _ref = this.pots;
        _results = [];
        for (fn in _ref) {
          pot = _ref[fn];
          _results.push(this.boil(pot.boil()));
        }
        return _results;
      }).call(this)).join('\n'));
    };

    Boiler.prototype.filenameToId = function(filename) {
      if (!(filename in this.filenameIdMap)) {
        this.filenameIdMap[filename] = this.id += 1;
      }
      return this.filenameIdMap[filename];
    };

    Boiler.isExcluded = function(path, config) {
      if (config.excluded || __indexOf.call(config.exclude, path) >= 0) {
        return true;
      } else if (config.parent) {
        return Boiler.isExcluded(path, config.parent);
      } else {
        return false;
      }
    };

    Boiler.injectScript = function(injects) {
      var alias, arg, args, scripts, strArgs;
      if (injects == null) {
        injects = {};
      }
      scripts = (function() {
        var _results;
        _results = [];
        for (alias in injects) {
          args = injects[alias];
          strArgs = ((function() {
            var _i, _len, _results1;
            _results1 = [];
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              arg = args[_i];
              _results1.push(JSON.stringify(arg));
            }
            return _results1;
          })()).join(',');
          _results.push("var " + alias + "=require(" + strArgs + ");\n");
        }
        return _results;
      })();
      if (scripts.length > 0) {
        return "// Boiler injects\n" + (scripts.join(''));
      } else {
        return '';
      }
    };

    Boiler.exportScript = function(exp) {
      if (exp) {
        return "\n;\n// Boiler exports\nmodule.exports=" + exp + ";";
      } else {
        return '';
      }
    };

    Boiler.injectExportWrap = function(pot, code) {
      return Boiler.injectScript(pot.config.injects) + code + Boiler.exportScript(pot.config.exports);
    };

    Boiler.requireWrap = function(code) {
      return "require = function(req) {\n  var fake = function(path, opt) {\n    var res;\n    module.__boiler_hook_in(req.resolve, path, opt);\n    try {\n      res = req.call(this, path);\n    } catch (err) {\n      module.__boiler_hook_error(err);\n    } finally {\n      module.__boiler_hook_out();\n    }\n    return res;\n  };\n  for (var i in req) {\n    fake[i] = req[i];\n  }\n  return fake;\n}(require);\n" + code;
    };

    Boiler.registerWrap = function(id, pathIdMap, code, filename) {
      return "register.call(this," + id + "," + (JSON.stringify(pathIdMap)) + ",\nfunction(require,exports,module){\n// Boiler file: " + (path_.relative(process.cwd(), filename)) + "\n" + code + "\n});";
    };

    Boiler.browserWrap = function(code) {
      return "(function(everything){\n  window.boiler={main:{}};\n  var idModuleMap={};\n  function emulateRequire(pathIdMap){\n    function require(path, opt){\n      return idModuleMap[pathIdMap[path]];\n    }\n    return require;\n  }\n  function register(id,pathIdMap,factory){\n    var module={exports:{}};\n    factory.call(this,emulateRequire(pathIdMap),module.exports,module);\n    window.boiler.main=idModuleMap[id]=module.exports;\n  }\n  everything.call(this,register);\n}).call(this,function(register){\n" + code + "\n});";
    };

    Boiler.inHook = function(pot, resolve, path, opt) {
      var alias, args, exclude, filename, injects, p, reqOpt;
      if (opt == null) {
        opt = {};
      }
      debug("hook into " + path);
      filename = resolve(path);
      if (typeof opt === 'string') {
        opt = {
          exports: opt
        };
      } else if (opt === true || opt instanceof Array) {
        opt = {
          exclude: opt
        };
      } else if (opt instanceof Object && !hasProp(opt, ['exclude', 'exports', 'injects'])) {
        opt = {
          injects: opt
        };
      }
      exclude = (function() {
        var _i, _len, _ref, _results;
        _ref = (opt.exclude instanceof Array ? opt.exclude : []);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(resolve(p));
        }
        return _results;
      })();
      injects = toDict((function() {
        var _ref, _ref1, _results;
        _ref = opt.injects || {};
        _results = [];
        for (alias in _ref) {
          p = _ref[alias];
          if (p instanceof Array) {
            _ref1 = p, p = _ref1[0], reqOpt = _ref1[1];
          }
          args = [relativeModule(filename, resolve(p))];
          if (reqOpt != null) {
            args.push(reqOpt);
          }
          _results.push([alias, args]);
        }
        return _results;
      })());
      return pot.config = pot.config.deps[path] = {
        filename: filename,
        exclude: exclude,
        injects: injects,
        exports: opt.exports,
        excluded: opt.exclude === true || Boiler.isExcluded(filename, pot.config),
        parent: pot.config,
        deps: {}
      };
    };

    Boiler.errorHook = function(pot, err) {
      return debug("hook error " + pot.config.filename + ": " + err);
    };

    Boiler.outHook = function(pot) {
      debug("hook outof " + pot.config.filename);
      if (pot.config.parent) {
        return pot.config = pot.config.parent;
      }
    };

    Boiler.getHook = function(pot, ext, func) {
      var hook;
      hook = function(module_, filename) {
        var cmp, msg;
        cmp = module_._compile;
        module_.__boiler_hook_in = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          Boiler.inHook.apply(Boiler, [pot].concat(__slice.call(args)));
          return module_.__boiler_hook_in = (function() {});
        };
        module_.__boiler_hook_out = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          Boiler.outHook.apply(Boiler, [pot].concat(__slice.call(args)));
          return module_.__boiler_hook_out = (function() {});
        };
        module_.__boiler_hook_error = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return Boiler.errorHook.apply(Boiler, [pot].concat(__slice.call(args)));
        };
        module_._compile = function(content, filename) {
          var code, nodeCode, res;
          debug(module_.filename);
          if (path_.basename(module_.filename, '.js') === 'boiler') {
            code = nodeCode = pot.config.code = module.exports.__boiler_code;
          } else {
            code = pot.config.code = Boiler.injectExportWrap(pot, content);
            debug("adding fake require to " + filename);
            nodeCode = Boiler.requireWrap(code);
          }
          res = cmp.call(this, nodeCode, filename);
          return res;
        };
        try {
          func(module_, filename);
        } catch (err) {
          msg = err.toString();
          if (msg.indexOf('Error: Cannot find module') === 0) {
            console.warn(msg, 'in file:', filename);
          }
          debug("Boiler error when running wrapped code:", err.stack);
        }
        return Boiler.hookExtensions(pot);
      };
      hook.__boiler_hook_orig = func;
      return hook;
    };

    Boiler.unhookExtensions = function() {
      var ext, func, _ref, _results;
      _ref = require.extensions;
      _results = [];
      for (ext in _ref) {
        func = _ref[ext];
        if (func.__boiler_hook_orig != null) {
          _results.push(require.extensions[ext] = func.__boiler_hook_orig);
        }
      }
      return _results;
    };

    Boiler.hookExtensions = function(pot) {
      var ext, func, _ref, _results;
      _ref = require.extensions;
      _results = [];
      for (ext in _ref) {
        func = _ref[ext];
        if (!(func.__boiler_hook_orig != null)) {
          _results.push(require.extensions[ext] = Boiler.getHook(pot, ext, func));
        }
      }
      return _results;
    };

    return Boiler;

  })();

  module.exports = function(req, path, opt) {
    var pot;
    pot = new Pot(req.resolve(path, false));
    Boiler.inHook(pot, req.resolve, path, opt);
    return pot.require();
  };

  module.exports.Boiler = Boiler;

  module.exports.debug = false;

  module.exports.__boiler_exclude = false;

  module.exports.__boiler_code = "module.exports=function(req, path, opt){return req(path, opt);};";

}).call(this);
